# 341. 扁平化嵌套列表迭代器

![难度](https://img.shields.io/badge/难度-中等-f0ad4e.svg?logo=leetcode&style=flat)  ![类型](https://img.shields.io/badge/类型-stack-violet.svg?style=flat)

---

## 题目描述

给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的项或者为一个整数，或者是另一个列表。

**示例 1:**

&emsp;**输入:** `[[1,1],2,[1,1]]`  
&emsp;**输出:** `[1,1,2,1,1]`  
&emsp;**解释:** 通过重复调用 `next` 直到 `hasNext` 返回 `false`，`next` 返回的元素的顺序应该是: `[1,1,2,1,1]`。  

**示例 2:**

&emsp;**输入:** `[1,[4,[6]]]`  
&emsp;**输出:** `[1,4,6]`  
&emsp;**解释:** 通过重复调用 `next` 直到 `hasNext` 返回 `false`，`next` 返回的元素的顺序应该是: `[1,4,6]`。  

> 来源：力扣（LeetCode）  
> 链接：https://leetcode-cn.com/problems/flatten-nested-list-iterator  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

---

## 解题说明

使用一个栈，保存List的迭代器，构造函数中先把父链表的迭代器压栈。  

`hasNext()` 函数中，取出栈顶的迭代器：  
- 如果迭代器没有元素了，则出栈，取出下一个迭代器  
- 如果迭代器还有元素，去除下一个元素，判断如是否为 `Integer`：  
    + 如果是，迭代器回退，函数返回 `true`；  
    + 如果不是，则为 `List`，把这个子 `List` 的迭代器压栈，继续循环;  
如此循环，如果直到栈为空还没返回 `true` 的话，说明真的没元素了，返回 `false`。

至于 `next()` 函数，因为在 `hasNext()` 里边已经让栈顶的迭代器处在了一个 `Integer` 前面，所以只要直接读出栈顶迭代器，调用它的 `next()` 方法，取出其中的数字，并返回就可以了。  
然而，考虑到应用中可能并不会在每次调用 `next()` 前都调用 `hasNext()`，所以最好还是在 `next()` 方法里边也实现 `hasNext()` 中类似的功能，比较符合实际情况。