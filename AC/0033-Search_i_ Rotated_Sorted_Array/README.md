# 33. 搜索旋转排序数组

![难度](https://img.shields.io/badge/难度-中等-f0ad4e.svg?logo=leetcode&style=flat)  ![类型](https://img.shields.io/badge/类型-数组-violet.svg?style=flat)

---

## 题目描述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

> 来源：力扣（LeetCode）  
> 链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

## 解题说明

### 多次二分查找

可以先用**二分查找**找到旋转数组最小元素所在的位置，这样就把数组分成了两个递增的有序数组。然后再在两个子数组里边进行二分查找，复杂度为 O(logn)。

因为题目假设不存在重复的元素，所以寻找旋转数组的最小元素要简单一些。

令 `s` 指向数组头部，`e` 指向数组尾部，`mid = (s + e) / 2`。

```
s         e
0 1 2 3 4 5
    |
  | |
| | |
| | |     |
| | |   | |
| | | | | |
: A :  B  :
```

如上所示，数组被分成两个递增的子数组 A 和 B，考虑更一般的情况，`mid` 可能落在 A 区，也可能落在 B 区，判断条件可以有很多，比如 `nums[mid] >= nums[s]` 则 `mid` 落在 A 区，相反则落在 B 区。如果是在 A 区，我们令 `s = mid`，B 区则 `e = mid`。这样可以保证目标区域每次都减半，且 `s` 永远在 A 区，`e`永远在 B 区。当目标区域缩小到只有两个元素时，`e` 指向的就是最小元素。

除此之外还有例外情况，就是原数组只有一个元素，或者本来就是从小到大递增的，在程序最开始的时候判断一下 `if (nums[s] <= nums[e])` 就行了。

这样就找到了最小元素的位置，把数组分成了两段，接下来在这两段里边进行二分查找就行了。

### 一趟二分查找

上面的方法使用了多次二分查找，才找到对应的位置。实际上只要把写好判断条件，一趟就能完成。先判断 `mid` 是落在 A 区还是 B 区，然后再在区域里边判断。比如 `mid` 如果在 A 区，如果 `target >= nums[s] && target < nums[mid]` 那么 `target` 就应该在 `[s, mid - 1]` 里边，否则就在 `[mid + 1, e]`里边。B 区类似。

