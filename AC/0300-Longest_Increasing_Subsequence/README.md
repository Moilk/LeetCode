# 300. 最长上升子序列

![难度](https://img.shields.io/badge/难度-中等-f0ad4e.svg?logo=leetcode&style=flat)  ![类型](https://img.shields.io/badge/类型-动态规划-violet.svg?style=flat)

---

## 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

&emsp;**输入:** [10,9,2,5,3,7,101,18]  
&emsp;**输出:** 4   
&emsp;**解释:** 最长的上升子序列是 [2,3,7,101]，它的长度是 4。  

&emsp;**说明:**  

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(n2) 。

**进阶:** 你能将算法的时间复杂度降低到 O(n log n) 吗?

> 来源：力扣（LeetCode）  
> 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence  
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  

## 解题说明

首先暴力法，对于每个元素有加入到序列中和不加入到序列中两种可能，用 i 表示当前元素索引，pre 表示当前上升子序列中最后一个元素的索引，首先，一种选择是不把当前元素加入序列中，有 `notTaken = lengthOfLIS(nums, lastIndex, index + 1, memo)`；另外，如果 nums[i] 比 nums[pre] 大，就可以把当前元素归到序列中去，有 `taken = 1 + lengthOfLIS(nums, index, index + 1, memo)`。这样，从 i 开始计算的话，最长子序列为这两种情况中较大的值，即 `res = max(taken, notTaken)`。如果用记忆化搜索的方法，这种算法的时间复杂度和空间复杂度都是 `O(n^2)`。

另外是动态规划，用 dp[i] 表示 [0 ~ i] 的子数组中最大上升子序列的长度。对于 dp[n]，需要遍历 [0 ~ n - 1] 的元素，这些元素中有些元素比 nums[n] 小，找出这些元素对应的 dp[i] 中的最大值，则 `dp[n] = max(dp[i])，nums[i] < nums[n]`。这样算法复杂度是 `O(n^2)`，空间复杂度是 `O(n^2)`。

最快的方法是动态规划 + 二分搜索。用 dp[] 保存当前上升子序列的元素，然后对于每个新元素，由于 dp[] 是有序的，所以可以用二分法查找新元素应该放在数组中的什么位置。具体过程如下所示：

```
[]  
[10]  
[9]  
[2]  
[2,5]  
[2,3]  
[2,3,7]  
[2,3,7,101]  
[2,3,7,18]  
```

用后来的新元素替换老元素不会影响最终结果：  

- 如果替换的是最后一个元素，如用 4 替换 [2,3,5] 中的 5，那么用更小的元素替换旧元素显然更容易得到更大的上升子序列；  
- 如果替换的是更前面的元素，只要最后一个元素还在，最长上升子序列的长度就不会受影响；  
- 如果是在后面追加元素，最正常不过的操作了。  

这样得到的最终数组的长度，就是最长上升子序列的长度。（但最终的数组并不最最长上升字序列）
