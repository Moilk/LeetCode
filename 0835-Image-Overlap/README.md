设图片的长宽为 `N`，只移动 A 不移动 B，为了覆盖到所有情况，A 横向和纵向的移动范围都是 `[-(N-1), N-1]`，假设 A 移动向量为 `(x, y), x, y ∈ [-(N-1), N-1]`，则图像 A 的有效范围为 `[asx, asy] ~ [aex, aey]`，图像 B 的有效范围为 `[bsx, bsy] ~ [bex, bey]`，其中：

```java
asx = bsx - x
asy = bsy - y
aex = bex - x
aey = bey - y

bsx = max(0, x)
bsy = max(0, y)
bex = min(N - 1 + x, N - 1)
bey = min(N - 1 + y, N - 1)
```

设 `(i, j)` 为图像 B 有效范围内的一点，则其对应图像 A 上的点为 `(i - x, j - y)`。

我们要做的就是遍历所有 `(x, y)`（这需要两层循环），然后在循环里边再遍历所有有效范围内的点（又需要两层循环），在最里层循环中统计重叠的点数，找到所有 `(x, y)` 中最大的重叠数，就是最后的结果